// (MV3 service worker)

const GRAPHQL_URL = "https://medium.com/_/graphql";
const BATCH_SIZE = 10; // how many GraphQL operations per POST body chunk
const REQUEST_TIMEOUT = 20000; // ms

// GraphQL operation templates
const OP_POST_STATS_TOTALS = `
query PostStatsTotals($input: PostStatsTotalBundleInput!) {
  postStatsTotalBundle(postStatsTotalBundleInput: $input) {
    postId
    viewersCount
    readersCount
    presentations
    claps
    fans
    readRatio
    clapRatio
    followersGained
    followersLost
    netFollowerCount
    subscribersGained
    subscribersLost
    netSubscriberCount
    externalReferralStat {
      domain
      count
    }
    internalReferralStat {
      source
      count
    }
  }
}
`;

// util: chunk array
function chunk(arr, n) {
    const out = [];
    for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n));
    return out;
}

async function postGraphqlBatch(operations) {
    // operations: [{operationName, variables, query}]
    try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);
        const res = await fetch(GRAPHQL_URL, {
            method: "POST",
            credentials: "include",
            headers: {
                "Content-Type": "application/json",
                "accept": "*/*",
                "x-client-version": "web-2025.01.15",
                "x-acquire-token": "true"
            },
            body: JSON.stringify(operations),
            signal: controller.signal
        });
        clearTimeout(timeout);
        if (!res.ok) throw new Error("GraphQL fetch failed: " + res.status);
        const text = await res.text();
        // Medium responds with JSON lines sometimes; parse robustly
        try {
            console.log("GraphQL response text:", JSON.parse(text));
            return JSON.parse(text);
        } catch (e) {
            console.log("GraphQL response error text:", e);
            // fallback: trim and try parse
            return JSON.parse(text.trim());
        }
    } catch (err) {
        console.warn("postGraphqlBatch error", err);
        throw err;
    }
}

// Build operations array for a list of postIds. For each post id we'll create three operations (claps, totals, impact)
function buildOperationsForIds(ids) {
    const ops = [];
    for (const id of ids) {
        ops.push({
            operationName: "PostStatsTotals",
            query: OP_POST_STATS_TOTALS,
            variables: { input: { postId: id } }
        });
    }
    return ops;
}

// Given the responses array (in same order as operations), assemble per-post results
function assembleResultsFromResponses(ids, responses) {
    const out = {};

    for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        const resp = responses[i]?.data?.postStatsTotalBundle;

        out[id] = {
            id,
            views: resp?.viewersCount ?? 0,
            reads: resp?.readersCount ?? 0,
            presentations: resp?.presentations ?? 0,
            claps: resp?.claps ?? 0,
            fans: resp?.fans ?? 0,
            readRatio: resp?.readRatio ?? 0,
            clapRatio: resp?.clapRatio ?? 0,
            followersGained: resp?.followersGained ?? 0,
            followersLost: resp?.followersLost ?? 0,
            netFollowerCount: resp?.netFollowerCount ?? 0,
            subscribersGained: resp?.subscribersGained ?? 0,
            subscribersLost: resp?.subscribersLost ?? 0,
            netSubscriberCount: resp?.netSubscriberCount ?? 0,
            externalReferrals: resp?.externalReferralStat || [],
            internalReferrals: resp?.internalReferralStat || []
        }
    }

    return out;
}

// Entrypoint: collect for a list of posts (items: [{id,title,href}]).
// We will build ops per id and send in batches of BATCH_SIZE * 3 (since 3 ops per id)
async function collectForItems(items) {
    const ids = items.map(i => i.id);
    if (!ids.length) return { stats: [], totals: {}, count: 0 };

    // build operations in the orderly triplet pattern
    const operations = buildOperationsForIds(ids);

    // chunk operations to avoid huge payloads
    const opChunks = chunk(operations, Math.max(1, BATCH_SIZE * 2)); // BATCH_SIZE posts -> 2*BATCH_SIZE ops
    const responses = [];

    for (const chunkOps of opChunks) {
        try {
            const resBatch = await postGraphqlBatch(chunkOps);
            // resBatch is an array of responses corresponding to chunkOps
            // append them in same order
            Array.prototype.push.apply(responses, resBatch);
        } catch (err) {
            // on failure, push placeholders for each op in this chunk
            for (let i = 0; i < chunkOps.length; i++) responses.push({ errors: [{ message: err.message }] });
        }
    }

    // Now responses length should equal operations length
    // assemble per post
    const assembled = assembleResultsFromResponses(ids, responses);

    // merge with titles/hrefs
    const stats = items.map(it => {
        const data = assembled[it.id] || {};
        return {
            title: it.title,
            href: it.href,
            id: it.id,
            claps: data.claps || 0,
            presentations: data.presentations || 0,
            views: data.views || 0,
            reads: data.reads || 0,
            feedClickThroughRate: data.feedClickThroughRate || 0,
            followersGained: data.followersGained || 0,
            followersLost: data.followersLost || 0,
            netFollowerCount: data.netFollowerCount || 0,
            subscribersGained: data.subscribersGained || 0,
            subscribersLost: data.subscribersLost || 0,
            netSubscriberCount: data.netSubscriberCount || 0
        };
    });

    // totals
    const totals = stats.reduce((acc, s) => {
        acc.presentations += s.presentations || 0;
        acc.views += s.views || 0;
        acc.reads += s.reads || 0;
        acc.claps += s.claps || 0;
        acc.followersGained += s.followersGained || 0;
        acc.subscribersGained += s.subscribersGained || 0;
        return acc;
    }, { presentations: 0, views: 0, reads: 0, claps: 0, followersGained: 0, subscribersGained: 0 });

    // store last result for popup quick fetch
    await chrome.storage.local.set({ lastMediumStats: { stats, totals, count: stats.length, fetchedAt: Date.now() } });

    return { stats, totals, count: stats.length };
}

async function executeScript() {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        files: ["script.js"]
    });
}

async function collectNow() {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tab || !tab.id) throw new Error("No active tab");

    // Inject code to extract posts from the current Medium page
    const scanResult = await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        func: () => {
            const anchors = Array.from(
                document.querySelectorAll(
                    'a[href*="/me/stats/post/"], a[href*="/p/"], a[href*="/post/"]'
                )
            );

            const uniq = [];
            const seen = new Set();

            anchors.forEach(a => {
                const href = a.href.split("?")[0];
                if (seen.has(href)) return;

                seen.add(href);
                const title =
                    (a.querySelector("h2, h3") ||
                        a.closest("article")?.querySelector("h2, h3") ||
                        a).innerText || "";

                uniq.push({ href, title });
            });

            return uniq;
        }
    });

    const items = scanResult?.[0]?.result || [];
    if (items.length === 0) return { stats: [], totals: {}, count: 0 };

    // Extract postId from URL
    const normalized = items.map(o => {
        const match = o.href.match(/\/p\/([0-9a-f]+)|\/post\/([0-9a-f]+)/i);
        const id = match ? (match[1] || match[2]) : null;
        return { ...o, id };
    }).filter(x => x.id);

    if (normalized.length === 0) return { stats: [], totals: {}, count: 0 };

    return await collectForItems(normalized);
}

async function collectStatsForPosts(posts) {
    if (!Array.isArray(posts) || posts.length === 0) {
        throw new Error("No posts provided");
    }

    const items = posts.map(p => {
        if (typeof p === "string") {
            // string → could be URL or postId
            const match = p.match(/([0-9a-f]{10,})/i);
            const id = match ? match[1] : null;
            return { id, href: p, title: "" };
        }
        if (typeof p === "object") {
            let id = p.id;

            if (!id && p.href) {
                const match = p.href.match(/([0-9a-f]{10,})/i);
                id = match ? match[1] : null;
            }

            return {
                id,
                href: p.href || "",
                title: p.title || ""
            };
        }

        return null;
    }).filter(x => x && x.id);

    if (items.length === 0) {
        throw new Error("No valid post IDs extracted");
    }

    return await collectForItems(items);
}

// Message handler
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (!msg || !msg.action) {
        sendResponse({ error: "no message" });
        return true;
    }

    // -------------------------------------------------------------------
    // 1. SCAN_MEDIUM_TAB
    // -------------------------------------------------------------------
    if (msg.action === "SCAN_MEDIUM_TAB") {
        chrome.scripting.executeScript(
            {
                target: { tabId: msg.tabId },
                func: () => {
                    const anchors = Array.from(
                        document.querySelectorAll(
                            'a[href*="/me/stats/post/"], a[href*="/p/"], a[href*="/post/"]'
                        )
                    );

                    const uniq = [];
                    const seen = new Set();

                    anchors.forEach(a => {
                        const href = a.href.split("?")[0];
                        if (seen.has(href)) return;

                        seen.add(href);
                        const title =
                            (a.querySelector("h2, h3") ||
                                a.closest("article")?.querySelector("h2, h3") ||
                                a).innerText || "";

                        uniq.push({ href, title });
                    });

                    return uniq;
                }
            },
            results => {
                if (chrome.runtime.lastError) {
                    console.warn("SCAN_MEDIUM_TAB error:", chrome.runtime.lastError);
                    sendResponse({ items: [] });
                } else {
                    sendResponse({
                        items: results?.[0]?.result || []
                    });
                }
            }
        );

        return true;
    }

    // -------------------------------------------------------------------
    // 2. collect  (Original collector handler)
    // -------------------------------------------------------------------
    if (msg.action === "collect") {
        const items = msg.posts || [];

        collectForItems(items)
            .then(result => sendResponse({ ok: true, result }))
            .catch(err => sendResponse({ error: err?.message || String(err) }));

        return true;
    }

    // -------------------------------------------------------------------
    // 3. getLast — return last saved stats from storage
    // -------------------------------------------------------------------
    if (msg.action === "getLast") {
        chrome.storage.local.get(["lastMediumStats"], value => {
            sendResponse(value.lastMediumStats || null);
        });

        return true;
    }

    // -------------------------------------------------------------------
    // 4. collectNow — triggered manually from UI (popup)
    // -------------------------------------------------------------------
    if (msg.action === "collectNow") {
        collectNow()
            .then(result => sendResponse({ ok: true, result }))
            .catch(err => sendResponse({ error: err?.message || String(err) }));

        return true;
    }

    // -------------------------------------------------------------------
    // 5. collectStatsForPosts — takes a list of post IDs or URLs
    // -------------------------------------------------------------------
    if (msg.action === "collectStatsForPosts") {
        const posts = msg.posts || [];

        collectStatsForPosts(posts)
            .then(result => sendResponse({ ok: true, result }))
            .catch(err => sendResponse({ error: err?.message || String(err) }));

        return true;
    }

    // -------------------------------------------------------------------
    // Unknown action fallback
    // -------------------------------------------------------------------
    sendResponse({ error: "unknown action" });
    return false;
});
